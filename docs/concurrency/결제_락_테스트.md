# 결제(주문 완료) 시 동시성 문제

### 1. 문제 식별
> 결제의 경우 가장 고려할 것이 많았습니다..

1. 결제 과정
   1) 재고 차감
      1) 재고 부족 시, 재고 원복 후 주문 실패 처리
   2) 포인트 사용
      1) 포인트 부족 시, 재고 & 포인트 원복 후 주문 실패 처리
   3) 주문 상태 변경
      1) 이미 다른 결제에 의해 주문이 완료 되었을 시, [i, ii] 과정의 재고 & 포인트 원복
   4) 결제 완료

- 해당 결제 과정에서 발생할 수 있는 결제 실패 시 원복 과정을 고려할 필요가 있습니다.
- 결제 실패 시에는 결제 과정중에 발생했던 트랜잭션에 의한 변경 사항을 다시 바꿀 필요가 있음..

---

### 2. 분석

주문 상태 변경 요청 A(SUCCESS)-> A(FAIL) -> A(FAIL) 일 경우 비관적 락일 경우, 한번 처리되면 더이상 처리될 필요가 없지만,, 마지막 상태가 반영이 될 우려가 있다고 생각해 낙관적 락을 선택하엿습니다.

- 재고 차감
  - 재고 차감의 경우, `비관적 락` 방식을 활용하였고, 재고(ProuctLine) 도메인에서, 재고가 부족할 시에 예외 처리를 하도록 책임을 부여하였습니다.
  - 하지만, `포인트 사용 / 주문 상태 변경` 과정에서 실패 시에, 차감된 재고를 다시 원복하는 로직(?)이 필요하다고 생각하였습니다.


- 포인트 사용
  - 포인트 부족 시, 사용하려는 금액이 현재 잔고(balance) 보다 많을 경우 도메인에서 예외처리를 하도록 책임을 부여하였습니다.
  - `userService.pointUse()` 함수에서 예외 발생시 @Transactional을 이용해 자동으로 save() 호출 까지 가지 않도록 되어있습니다.
  - `비관적 락 + Idempotent Key` 방식을 사용사용했으므로했으므로, 동일 주문에 대한 결제 요청에도 `DataIntegrityViolationException`예외가 발생하여 포인트 사용 결과가 반영되지 않습니다.
  

- 주문 상태 변경
  - 동일한 주문에 대해 결제 요청이 두 번 들어온다면, 낙관적 락을 통해서 둘 중에 한 요청에 대해서만 성공하도록 하는 방향으로 설계하였습니다.
  - 동일 주문에 대한 요청이 들어 왔을 경우, `재고 차감`에 대한 원복 로직만 수행하면 됩니다. (포인트 사용의 경우 Unique 제약으로 인해 자동 예외 처리됨)
  - 주문 실패 과정으로 변경 중, 이미 처리가 완료된 주문 일 경우 재 시도 로직을 계속해서 발생시키지 않도록 `(orders.status)` 칼럼을 확인하여 오버헤드를 방지합니다.

> 위 내용에 대한 도식화..

![img_7.png](img_7.png)


---

### 3. 해결

> (+ 미리 추신,,)
> 
> - 처음에는 PaymentFacade 에서 트랜잭션을 두지 않고, 하위 클래스의 호출 함수에서 @Transaction을 작성하였습니다..
> - 하지만, 스레드를 여러 개 발생시켜 요청을 하고, 하위 클래스의 호출 함수에서 던진 예외를 바탕으로
> - PaymentFacade에서 주문 실패, 재고 원복, 포인트 원복에 대한 처리를 하려다 보니,, 각각의 조회 시점도 다르고 @Transactional이 한 번에 실행된다는 보장이 없어서,,
> - 보기 좋게 실패하엿습니다.
> - 어쩔 수 없이 결제라는 하나의 과정이 전체 흐름을 관장한다는 생각으로,,, PaymentFacade에 트랜잭션을 다시 두니 해결되었습니다..

#### 3-1. 엔티티 버전 추가
```java
@Entity
@Table(name = "orders")
@Getter
@NoArgsConstructor
public class OrderJpaEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long orderId;

    private String orderCode;

    @Column(nullable = false)
    private Long userId;

    @Column(precision = 12, scale = 2)
    private BigDecimal totalPrice;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<OrderLineJpaEntity> orderLines = new ArrayList<>();

    @Column(
            nullable = false,
            columnDefinition = "DATETIME DEFAULT CURRENT_TIMESTAMP"
    )
    private LocalDateTime orderDt;

    @Column(nullable = false)
    private String status;

    @UpdateTimestamp
    @Column(
            name = "update_dt",
            nullable = false,
            columnDefinition = "DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"
    )
    private LocalDateTime updateDt;

    // 버전 추가
    @Version
    @Column(nullable = false, columnDefinition = "BIGINT NOT NULL DEFAULT 0")
    private Long version;


    public Order toDomain() {
        List<OrderLine> lines = orderLines.stream().map(OrderLineJpaEntity::toDomain).toList();
        return Order.builder()
                .version(version)
                .orderId(orderId)
                .orderCode(orderCode)
                .userId(userId)
                .totalPrice(totalPrice)
                .orderLines(lines)
                .orderDt(orderDt)
                .status(status)
                .updateDt(updateDt)
                .build();
    }

    public static OrderJpaEntity fromDomain(Order order) {
        OrderJpaEntity entity = new OrderJpaEntity();
        entity.orderId = order.getOrderId();
        entity.orderCode = order.getOrderCode();
        entity.totalPrice = order.getTotalPrice();
        entity.userId = order.getUserId();
        entity.orderLines = order.getOrderLines().stream()
                .map(line -> OrderLineJpaEntity.fromDomain(line, entity))
                .toList();
        entity.orderDt = LocalDateTime.now();
        entity.status = order.getStatus();
        entity.version = order.getVersion();
        return entity;
    }
}
```

```java
@Repository
public interface OrderJpaRepository extends JpaRepository<OrderJpaEntity, Long> {

    @Lock(LockModeType.OPTIMISTIC)
    @Query("select o from OrderJpaEntity o where o.orderCode = :code")
    Optional<OrderJpaEntity> findByOrderCodeWithLock(@Param("code") String code);
}
```