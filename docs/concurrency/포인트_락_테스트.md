
# 포인트 충전/사용 시 동시성 문제 해결

### 1. 문제 식별
- 포인트에 대한 동시성(락) 처리 로직이 없음으로, 동시에 여러 번의 충전 시 Race Condition이 발생할 우려가 있었습니다.

---

### 2. 분석
- 동시성 문제에 관해 두 가지 가정을 하였습니다.

- 서로 다른 요청 3가지
  - 1) 요청 A, B, C -> 유저 포인트 +A +B +C (3번충전)
  - 2) 요청 A, A, A -> 유저 포인트 +A (1번 충전)


- a 상황을 해결하기 위해 비관적락으로 할 경우,,, b 상황에서 같은 충전이 3번 일어날 것이고,,,
-  b 상황을 위해 낙관적락을 할 경우,,, a 상황에서 재시도 코드가 필연적이었습니다.

> 포인트 사용 혹은 충전에 대해서 결제 상황에서도 결제 실패 시 원복 요청이 있으므로,,, 결제 내부에서 재시도 처리까지 구현한다면 매우 복잡한 코드가 될 것이라고 생각하였습니다.

---

### 3. 해결
`비관적락 + Idempotent Key` 방식

포인트 엔티티 뿐만 아니라, 포인트 내역 엔티티에 String reqId 칼럼을 추가하여,
같은 요청에 대한 기록이 이미 저장되어 있으면, 동일 요청으로 확인 해 Persistent 계층에서의 예외를 활용하여 해결하기로 하였습니다.

- 이렇게 했을 때, 결제 과정 중에 포인트 충전이나 다른 주문에 의한 포인트 사용이 발생하더라도, 비관적 락에 의해 포인트 사용에 대한 락을 대기할 수 있으며,
- 중복 결제/동시 충전/동시 사용 으로 인해 발생할 수 있는 문제점들을 해결할 수 있기 때문에 비관적락을 선택하였습니다.

#### 3-1) 엔티티
```java
@Entity
@Table(name="point_records")
public class PointRecordJpaEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    Long pointRecordId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "point_id")
    private PointJpaEntity point;
    Long userId;

    @Column(
            name = "request_id",
            nullable = false,
            length = 100,
            unique = true
    )
    private String requestId;     // ← Idempotent Key

    BigDecimal amount;

    @Column(length = 10)
    String type;

    @UpdateTimestamp
    @Column(
            name = "update_dt",
            nullable = false,
            columnDefinition = "DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"
    )
    private LocalDateTime updateDt;

}
```

#### 3-2) 유저 충전 코드(서비스)
```java
@Transactional
public Users chargePointWithLock(Long userId, Object amount, String reqId){
    PointDao point = getPoint(userId); // 비관적 락 조회
    PointRecordDao records = recordOfCharge(point, new BigDecimal(amount.toString()), reqId);
    Users user = getUser(userId);
    try{
        user.pointCharge(amount);
        userRepository.save(user);

        point.setBalance(user.getBalance());
        pointRepository.save(point);
        pointRecordRepository.save(records);
        return user;
    }catch(DataIntegrityViolationException ex){
        throw new AlreadyProcessedPointException(point.getPointId(), "CHARGE", reqId);
    }
}
```
#### 3-3) 비관적 락 조회 (Jpa Repo)
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select p from PointJpaEntity p where p.userId = :id ")
    public Optional<PointJpaEntity> findByUserIdForUpdate(@Param("id") Long userId);
```

---

### 4. 사이드 이펙트

- 결제 과정 중, 잔고가 부족한 경우 -> 유저(포인트) 도메인에서 예외를 처리하도록 하여 @Transactional로 인한 자동 롤백 처리
- 결제 과정 중, 동일한 결제 요청으로 인해 주문 완료 된 경우 -> Idempotent Key로 인해 Unique 제약 조건에 걸려 @Transactional로 인해 자동 롤백 처리


- 결제 실패 시에만, 충전한 금액을 다시 원복하면 됩니다.