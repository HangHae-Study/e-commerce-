## Requirements
    - 잔액 충전 / 조회 API
    - 상품 조회 API
    - 주문 / 결제 API
    - 선착순 쿠폰 API
    - 인기 판매 상품 조회 API
- 각 기능 및 제약사항에 대해 단위 테스트를 반드시 하나 이상 작성하도록 합니다.
- **(심화)** 재고 관리에 문제 없도록 구현합니다.
- **(심화)** 동시성 이슈를 고려하여 구현합니다.
- **(심화)** 다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성하도록 합니다.

---

### 목표
- API 스펙을 작성하고 MockAPI를 만든 후, 테스트 코드 작성 후 -> API 명세서 결과물 만들기
- 스펙 작성 시, 나온 결과물 및 요구사항 산출물 만들기 (시퀀스, ERD, 클래스, 상태 다이어그램)
---

#### 1. 잔액 충전 시 (2가지 기본 기능)
- 유저의 식별자가 필요하다.
- 유저의 식별자에 따른 잔액이 존재한다.
- 금액을 받아 잔액을 충전한다.
- 유저의 식별자로 잔액을 조회한다.

#### 2. 상품 조회 시 (1가지 기본 기능)
- 상품 정보를 확인할 수 있다. (ID, 이름, 가격, 잔여수량)
- 상품 에는 재고가 존재하는데, 이를 원활히 관리할 것
    - (상품 1 - 재고 N, 옷도 사이즈별로 재고가 다 다르듯이)
- 조회 시점의 상품별 잔여수량이 정확하면 좋다 (?)
- 조회 과정 중, 다른 주문이 발생해 잔여 수량이 줄어 든다면? (동시성)

#### 3. 주문 / 결제 (2가지 기본 기능, 3가지 상태 [주문, 결제 대기, 결제 완료])
- 사용자 식별자 - 상품 ID & 수량 목록을 입력받아 주문하고 결제한다.
- 사용자 1 : 상품 N
    - 주문 1 - 주문 목록 N
- 결제 시, 기존 유저 식별자의 잔액을 기반으로 사용한만큼 잔액을 차감한다.
    - 잔액 충분 : 결제 성공
    - 잔액 부족 : 결제 실패
- 결제 성공 시, 데이터 분석을 위해 주문정보를 데이터 플랫폼에 전송함.


- 주문하기전 상태는,, 보통 장바구니에 담긴 이미지가 떠오르는데, 결제 전, 주문의 단위를 명확히 할 필요가 있음.


#### 4. 선착순 쿠폰 (2가지 기본 기능, 2가지 상태)
- 선착순 쿠폰 발급, 보유 쿠폰 목록 조회
- 할인 쿠폰 발생 시, 선착순으로 발급 가능.
- 주문 시 유효한 할인 쿠폰의 기준이 필요함.
    - 유효 날짜(쿠폰 사용 가능 기간 으로 예정)
    - 쿠폰 식별자 (사용자ID-쿠폰발급년월일-쿠폰SEQ)
- 주문 시 할인 금액 적용시, 할인 혜택
- 할인 - 주문 간 연동 정보 (매핑 기준 필요)

#### 5. 상위 상품 조회
- 최근 3일간 가장 많이 팔린 상위 5개 상품
- 주문 정보에는 주문 일시가 필요함.
- 통계 정보.

#### 6. 심화
- 다수 인스턴스(여러 서버) 에서 어플리케이션이 동작할 때도 기능이 문제가 없도록 해야함.

---

### 시퀀스 다이어그램 꼭지점
사용자 - 상품 - 재고 - 주문 - 쿠폰 - 잔액 - 결제

중간 모든 과정에 정책 넣어주자.
(음수 충전, 음수 결제, 결제 최대 금액, 할인 최대/최소 금액)

#### TDD를 이론 관점에서 먼저 진행하고, 시나리오를 짜본다면?

- 충전
    - 단위
        - 유저가 포인트를 조회한다. (단위 테스트)
        - 유저가 충전을 하면, 잔액에 충전 금액을 더한 후 결과를 뱉는다.
    - 단위 이상
        - 유저가 포인트를 동시에 충전했을 때, 모든 충전 내역이 반영 되어야 한다.
        - 유저의 결제 시점과, 충전 시점이 동시에 발생한다면, 결제 완료 후 잔액이 올바르게 반영 되어야한다.


- 상품 & 재고
  - 단위
    - 유저가 상품을 조회한다.
    - 상품 조회 시에는, 상품 목록 & 상품 상세 정보
      - 상품의 상세 정보에는 잔여수량이 존재한다.
    - 각 상품은 ID 식별자를 가진다.
    - 상품 상세 정보 내에 있는 재고에도 ID가 있고, 상품의 부모 ID 또한 키로 가진다.
    - 조회 시점의 상품 잔여 수량을 가져온다.
    

- 주문
  (상태 : 주문 대기, 보류(결제 대기) -> 결제 완료 or 결제 실패 -> 주문 완료 -> 주문 실패)
  - 단위
    - 주문 하나에는 여러 개의 상품(재고)이 존재할 수 있다.
    - 한 사용자는 한 번에 하나의 주문을 발생시킨다.
    - 주문 시, 쿠폰을 이용한 할인 금액으로 결제 정보를 발생시킬 수 있다.
  - 단위 이상
    - (with 결제) 주문 요청 시에는 주문 정보가 서버에 반영되고, 결제를 위한 정보를 응답한다.
      - 결제를 위한 정보에는 주문 ID가 반환됨.
    - (with 재고) 주문 정보가 생성되면(서버에 반영되면), 재고 잔여수량이 감소한다.
    - (with 쿠폰) 쿠폰을 이용하여 주문 완료 시, 보유한 쿠폰이 unvalid한 상태가 된다.
    - (with 재고) 주문 정보가 하루 이상 결제 완료 상태로 변경되지 않으면, "결제 실패"로 변경한다.


- 결제
  - 단위
    - 주문 후, 결제 시도 시 잔액이 충분할 경우 결제에 성공한다.
    - 주문 후, 결제 시도 시 잔액이 부족한 경우 결제에 실패한다.
  - 단위 이상
    - 결제 성공 시
      - (with 잔액) 사용자 (ID)가 가진 포인트 잔액을 결제 금액만큼 차감한다.
      - (with 주문)주문 정보를 주문 완료 상태로 변경한다. (left outer join??)
    - 결제 실패 시
      - (with 재고) 결제 요청에 들어온 주문 ID에 있는 상품(재고)들의 잔여 수량이 증가한다.
      - (with 쿠폰) 결제 요청에 들어온 주문 ID에 있는 쿠폰의 상태가 valid한 상태로 변경된다.
      

- 쿠폰
  - 단위
    - 유저가 쿠폰을 발행한다.
    - 유저 쿠폰 발행시, 쿠폰의 잔량이 감소한다.
  - 단위 이상
    - 선착순 쿠폰 발행 시, 다수 유저에 대한 쿠폰 발행에 대해 쿠폰 잔량 감소가 모두 이뤄져야 한다. 
    - (with 주문, 결제) 쿠폰 적용 후 주문 완료(결제완료)시, 쿠폰이 더 이상 사용될 수 없다.
      - 쿠폰 unvalid 상태에 대한 책임을 주문 or 결제 어디에 둘지 고민